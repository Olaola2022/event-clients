"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Redis = require("redis");
var timers_1 = require("timers");
var EventBus = /** @class */ (function () {
    function EventBus(name, clientOpts) {
        this._pub = Redis.createClient(clientOpts);
        this._sub = Redis.createClient(clientOpts);
        //Save prefix for filtering subscriptions on prefix later on
        if (clientOpts && clientOpts.prefix) {
            this._prefix = clientOpts.prefix;
        }
        else {
            this._prefix = '';
        }
    }
    EventBus.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    //Listen for ping event
                    return [4 /*yield*/, this._on('ping', function () {
                            //Emit pong event
                            _this._emit('pong', '', true);
                        }, true)];
                    case 1:
                        //Listen for ping event
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    //Register event listener
    EventBus.prototype.on = function (event, callback) {
        return this._on(event, callback, false);
    };
    EventBus.prototype._on = function (event, callback, internalCall) {
        var _this = this;
        if (internalCall === void 0) { internalCall = true; }
        return new Promise(function (resolve, reject) {
            //Check if event is reserved event name
            if (!internalCall && _this.isReservedEventName(event)) {
                reject(new Error("Reserved event name " + event + " cannot be registered"));
            }
            //Listen for the subscribe event
            _this._sub.on('subscribe', function (channel, count) {
                var _channel = _this.removePrefixFromChannelName(channel);
                if (_channel === event) {
                    resolve();
                }
            });
            //Listen for the message event
            _this._sub.on('message', function (channel, message) {
                var _channel = _this.removePrefixFromChannelName(channel);
                if (event === _channel) {
                    callback(message);
                }
            });
            //Subscribe on the event bus
            _this._sub.subscribe(_this.getPrefixedChannelName(event));
        });
    };
    //Emit a new event to the event bus
    EventBus.prototype.emit = function (event, payload) {
        return this._emit(event, payload, false);
    };
    EventBus.prototype._emit = function (event, payload, internalCall) {
        if (internalCall === void 0) { internalCall = true; }
        //Check if event is reserved event name
        if (!internalCall && this.isReservedEventName(event)) {
            throw new Error("Reserved event name " + event + " cannot be emitted");
        }
        this._pub.publish(this.getPrefixedChannelName(event), typeof payload === 'string' ? payload : JSON.stringify(payload));
    };
    /*
        Send out a ping to all connected instances
        Waits for <timeout> seconds and returnes true, if at least <minResponseCount> clients responded
    */
    EventBus.prototype.ping = function (timeout, minResponseCount) {
        var _this = this;
        if (timeout === void 0) { timeout = 3000; }
        if (minResponseCount === void 0) { minResponseCount = 1; }
        return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
            var responseCount, timeoutRef;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        responseCount = 0;
                        timeoutRef = setTimeout(function () {
                            //+1 because our instance itself will respond
                            resolve(responseCount >= minResponseCount + 1);
                        }, timeout);
                        return [4 /*yield*/, this._on('pong', function () {
                                responseCount++;
                                //+1 because our instance itself will respond
                                if (responseCount >= minResponseCount + 1) {
                                    //Cleat timeout
                                    timers_1.clearTimeout(timeoutRef);
                                    resolve(true);
                                }
                            }, true)];
                    case 1:
                        _a.sent();
                        this._emit('ping', '', true);
                        return [2 /*return*/];
                }
            });
        }); });
    };
    //Destroy event bus instance
    EventBus.prototype.destory = function () {
        this._sub.unsubscribe();
        this._sub.quit();
        this._pub.quit();
        if (EventBus._eventBusInstances.has(this._name)) {
            EventBus._eventBusInstances.delete(this._name);
        }
    };
    Object.defineProperty(EventBus.prototype, "connected", {
        //Returns connection status of redis client
        get: function () {
            if (this._pub && this._sub) {
                return this._pub.connected && this._sub.connected;
            }
            else {
                throw new Error('Event bus instance is undefined');
            }
        },
        enumerable: true,
        configurable: true
    });
    //Private util methods
    EventBus.prototype.removePrefixFromChannelName = function (channel) {
        if (this._prefix.length > 0) {
            return channel.substr(this._prefix.length + 1, channel.length - this._prefix.length);
        }
        else {
            return channel;
        }
    };
    EventBus.prototype.getPrefixedChannelName = function (channel) {
        return "" + (this._prefix.length > 0 ? this._prefix + ":" : '') + channel;
    };
    EventBus.prototype.isReservedEventName = function (event) {
        return event === 'ping' || event === 'pong';
    };
    //Factory method
    EventBus.create = function (name, clientOpts) {
        return __awaiter(this, void 0, void 0, function () {
            var instance, _clientOpts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        //Lazy init event bus instances map
                        if (EventBus._eventBusInstances === undefined || EventBus._eventBusInstances === null) {
                            EventBus._eventBusInstances = new Map();
                        }
                        instance = EventBus._eventBusInstances.get(name);
                        _clientOpts = {};
                        if (clientOpts) {
                            _clientOpts = __assign({}, clientOpts);
                        }
                        _clientOpts = __assign({}, _clientOpts, { 
                            //Preserve prefix if exists to avoid collisions
                            prefix: (_clientOpts.prefix !== undefined ? _clientOpts.prefix : '') + "node-redis-eventbus:" + name });
                        if (!(instance !== undefined)) return [3 /*break*/, 1];
                        return [2 /*return*/, instance];
                    case 1:
                        //Create new instance
                        instance = new EventBus(name, clientOpts);
                        //Init instance
                        return [4 /*yield*/, instance.init()];
                    case 2:
                        //Init instance
                        _a.sent();
                        //Store to map
                        EventBus._eventBusInstances.set(name, instance);
                        return [2 /*return*/, instance];
                }
            });
        });
    };
    EventBus.getByName = function (name) {
        //Lazy init event bus instances map
        if (EventBus._eventBusInstances === undefined || EventBus._eventBusInstances === null) {
            EventBus._eventBusInstances = new Map();
        }
        //Return stored or new instance
        var instance = EventBus._eventBusInstances.get(name);
        if (instance !== undefined) {
            return instance;
        }
        else {
            throw new Error("An event bus instance with the name " + name + " cannot be found.");
        }
    };
    return EventBus;
}());
exports.EventBus = EventBus;
//# sourceMappingURL=index.js.map